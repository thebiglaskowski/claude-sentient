# Go Project Profile
# Loaded when go.mod or *.go detected

name: go
version: "1.1"
description: "Go projects using golangci-lint for linting and go test for testing"

# Model routing configuration
models:
  default: sonnet
  planning: opus      # Use opus for architecture decisions
  exploration: haiku  # Use haiku for fast codebase exploration
  security: opus      # Use opus for security audits
  by_phase:
    init: haiku
    understand: sonnet
    plan: sonnet      # Upgrade to opus for "architecture" keywords
    execute: sonnet
    verify: sonnet
    commit: haiku
    evaluate: haiku

# Extended thinking configuration
thinking:
  max_tokens: 16000
  extended_for:
    - architecture
    - security
    - concurrency
    - channel-design
    - interface-design

# How to detect this profile
detection:
  files:
    - go.mod
    - go.sum
  patterns:
    - "**/*.go"

# Quality gate commands
gates:
  lint:
    command: golangci-lint run
    alternative: go vet ./...
    description: Check code quality and style

  test:
    command: go test ./...
    verbose_command: go test -v ./...
    coverage_command: go test -cover ./...
    description: Run test suite

  build:
    command: go build ./...
    description: Build all packages

  format:
    command: gofmt -w .
    check_command: gofmt -d .
    description: Format Go code

# Thresholds
thresholds:
  coverage: 80
  complexity: 15

# Common patterns in Go projects
patterns:
  - name: cmd-layout
    indicator: cmd/

  - name: internal
    indicator: internal/

  - name: pkg
    indicator: pkg/

  - name: cobra-cli
    indicator: "cobra.Command"

  - name: gin
    indicator: "github.com/gin-gonic/gin"

  - name: echo
    indicator: "github.com/labstack/echo"

# Web project detection (auto-loads UI/UX rules)
web_indicators:
  patterns:
    - "github.com/gin-gonic/gin"
    - "github.com/labstack/echo"
    - "github.com/gofiber/fiber"
    - "net/http"
    - "html/template"
  auto_rules: [ui-ux-design]

# Conventions
conventions:
  - Use gofmt/goimports for formatting
  - Error handling with explicit checks (no panic in libraries)
  - Prefer table-driven tests
  - Use context.Context for cancellation
  - Interfaces in consumer packages, not producer
  - Keep main.go minimal, logic in internal/

# File templates
templates:
  test: |
    package {package}

    import "testing"

    func Test{Function}(t *testing.T) {
        tests := []struct {
            name string
            want interface{}
        }{
            {"basic", nil},
        }
        for _, tt := range tests {
            t.Run(tt.name, func(t *testing.T) {
                // Arrange

                // Act

                // Assert
            })
        }
    }

# Ignore patterns for search
ignore:
  - vendor
  - .git
  - "*.exe"
  - "*.test"
  - "*.out"
