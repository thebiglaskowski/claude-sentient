# Go Project Profile
# Loaded when go.mod or *.go detected

name: go
version: "1.0"

# How to detect this profile
detection:
  files:
    - go.mod
    - go.sum
  patterns:
    - "**/*.go"

# Quality gate commands
gates:
  lint:
    command: golangci-lint run
    alternative: go vet ./...
    description: Check code quality and style

  test:
    command: go test ./...
    verbose_command: go test -v ./...
    coverage_command: go test -cover ./...
    description: Run test suite

  build:
    command: go build ./...
    description: Build all packages

  format:
    command: gofmt -w .
    check_command: gofmt -d .
    description: Format Go code

# Thresholds
thresholds:
  coverage: 80
  complexity: 15

# Common patterns in Go projects
patterns:
  - name: cmd-layout
    indicator: cmd/

  - name: internal
    indicator: internal/

  - name: pkg
    indicator: pkg/

  - name: cobra-cli
    indicator: "cobra.Command"

  - name: gin
    indicator: "github.com/gin-gonic/gin"

  - name: echo
    indicator: "github.com/labstack/echo"

# Conventions
conventions:
  - Use gofmt/goimports for formatting
  - Error handling with explicit checks (no panic in libraries)
  - Prefer table-driven tests
  - Use context.Context for cancellation
  - Interfaces in consumer packages, not producer
  - Keep main.go minimal, logic in internal/

# File templates
templates:
  test: |
    package {package}

    import "testing"

    func Test{Function}(t *testing.T) {
        tests := []struct {
            name string
            want interface{}
        }{
            {"basic", nil},
        }
        for _, tt := range tests {
            t.Run(tt.name, func(t *testing.T) {
                // Arrange

                // Act

                // Assert
            })
        }
    }

# Ignore patterns for search
ignore:
  - vendor
  - .git
  - "*.exe"
  - "*.test"
  - "*.out"
