# C/C++ Project Profile
# Loaded when CMakeLists.txt or Makefile detected

name: cpp
version: "1.0"
description: "C/C++ projects using clang-tidy for linting, ctest for testing, and cmake/make for building"

# Model routing configuration
models:
  default: sonnet
  planning: opus      # Use opus for architecture decisions
  exploration: haiku  # Use haiku for fast codebase exploration
  security: opus      # Use opus for security audits
  by_phase:
    init: haiku
    understand: sonnet
    plan: sonnet      # Upgrade to opus for "architecture" keywords
    execute: sonnet
    verify: sonnet
    commit: haiku
    evaluate: haiku

# Extended thinking configuration
thinking:
  max_tokens: 16000
  extended_for:
    - architecture
    - security
    - memory-management
    - concurrency
    - template-metaprogramming

# How to detect this profile
detection:
  files:
    - CMakeLists.txt
    - Makefile
    - meson.build
    - configure.ac
  patterns:
    - "**/*.cpp"
    - "**/*.c"
    - "**/*.h"
    - "**/*.hpp"

# Quality gate commands
gates:
  lint:
    command: clang-tidy **/*.cpp **/*.c
    alternative: cppcheck --enable=all .
    description: Check code quality

  test:
    command: ctest
    alternative: make test
    description: Run test suite

  build:
    command: cmake --build build
    alternative: make
    description: Build project

  format:
    command: clang-format -i **/*.cpp **/*.c **/*.h **/*.hpp
    check_command: clang-format --dry-run --Werror **/*.cpp
    description: Format C/C++ code

# Thresholds
thresholds:
  coverage: 70
  complexity: 15

# Common patterns in C/C++ projects
patterns:
  - name: cmake
    indicator: CMakeLists.txt
    tools:
      build: cmake --build

  - name: make
    indicator: Makefile
    tools:
      build: make

  - name: meson
    indicator: meson.build
    tools:
      build: meson compile

  - name: qt
    indicator: QApplication

  - name: boost
    indicator: boost/

# Conventions
conventions:
  - Use RAII for resource management
  - Prefer smart pointers over raw pointers
  - Use const correctness
  - Follow naming conventions (snake_case or camelCase consistently)
  - Use header guards or #pragma once

# File templates
templates:
  header: |
    #pragma once

    namespace {namespace} {

    class {ClassName} {
    public:
        {ClassName}();
        ~{ClassName}();

    private:
    };

    } // namespace {namespace}

  test: |
    #include <gtest/gtest.h>
    #include "{header}"

    TEST({TestSuite}, {TestName}) {
        // Arrange

        // Act

        // Assert
        EXPECT_TRUE(true);
    }

# Ignore patterns for search
ignore:
  - build
  - cmake-build-*
  - .cache
  - "*.o"
  - "*.a"
  - "*.so"
  - "*.dylib"
